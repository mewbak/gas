// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
// Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program.  If not, see <http://www.gnu.org/licenses/>.

package scanner

import (
	"bufio"
	"io"
)

// Scanner provides an interface to read operands of a GNU assembler instruction.
type Scanner struct {
	r        io.ByteReader
	err      error
	buf      []byte
	lastByte int
}

// NewScanner returns a new Scanner to read from r.
func NewScanner(r io.Reader) *Scanner {
	s := Scanner{lastByte: -1}
	if br, ok := r.(io.ByteReader); ok {
		s.r = br
	} else {
		s.r = bufio.NewReader(r)
	}
	return &s
}

// Scan advances the Scanner to the next token, which will then be
// available through the Text method. It returns false when the
// scan stops, either by reaching the end of the input or an error.
// After Scan returns false, the Err method will return any error that
// occurred during scanning, except that if it was io.EOF, Err
// will return nil.
func (s *Scanner) Scan() bool {
	if s.err != nil {
		return false
	}

	if s.lastByte != -1 {
		s.buf = append(s.buf, byte(s.lastByte))
		s.lastByte = -1
		return true
	}

	for {
		b, err := s.r.ReadByte()
		if err != nil {
			s.err = err
			return (err == io.EOF && len(s.buf) > 0)
		}

		switch b {
		case '%', '(', ')', ',', ':':
			if len(s.buf) > 0 {
				s.lastByte = int(b)
			} else {
				s.buf = append(s.buf, b)
			}
			return true
		default:
			s.buf = append(s.buf, b)
		}
	}
}

// Err returns the first non-EOF error that was encountered by the Scanner.
func (s *Scanner) Err() error {
	if s.err == io.EOF {
		return nil
	}
	return s.err
}

// Text returns the most recent token generated by a call to Scan.
func (s *Scanner) Text() string {
	text := string(s.buf)
	s.buf = s.buf[:0]
	return text
}
